(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ng-password-validator', ['exports', '@angular/core', 'rxjs', '@angular/common'], factory) :
    (global = global || self, factory(global['ng-password-validator'] = {}, global.ng.core, global.rxjs, global.ng.common));
}(this, (function (exports, core, rxjs, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * This is not a real service, but it looks like it from the outside.
     * It's just an InjectionToken used to import the config (initOptions) object, provided from the outside
     */
    var NgPasswordValidatorService = new core.InjectionToken("NgPasswordValidatorOptions");

    var defaultOptions = {
        placement: "bottom",
        "z-index": 0,
        "custom-class": "custom-class",
        shadow: true,
        theme: "pro",
        offset: 8,
        heading: "Password Policy",
        successMessage: "Awesome! Password requirement fulfilled.",
        rules: {
            password: {
                type: "range",
                length: 8,
                min: 6,
                max: 10,
            },
            "include-symbol": true,
            "include-number": true,
            "include-lowercase-characters": true,
            "include-uppercase-characters": true,
        }
    };
    var initializeStage = {
        password: false,
        "include-symbol": false,
        "include-number": false,
        "include-lowercase-characters": false,
        "include-uppercase-characters": false,
    };

    var DataService = /** @class */ (function () {
        function DataService() {
            this.value = new rxjs.BehaviorSubject(initializeStage);
            this.updatedValue = this.value.asObservable();
        }
        /**
         * Update value
         *
         * @param {IStatus} data
         * @memberof DataService
         */
        DataService.prototype.updateValue = function (data) {
            this.value.next(data);
        };
        DataService = __decorate([
            core.Injectable()
        ], DataService);
        return DataService;
    }());

    var NgPasswordValidatorComponent = /** @class */ (function () {
        function NgPasswordValidatorComponent(elementRef, renderer, dataService) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.dataService = dataService;
            this.passwordStatus = {
                password: false,
                "include-symbol": false,
                "include-number": false,
                "include-lowercase-characters": false,
                "include-uppercase-characters": false,
            };
            this.isSecure = false;
            this.Show = false;
            this.events = new core.EventEmitter();
            this.passwordOptions = __assign({}, defaultOptions);
        }
        /**
         * Host listener transition end
         *
         * @memberof NgPasswordValidatorComponent
         */
        NgPasswordValidatorComponent.prototype.transitionEnd = function () {
            if (this.show) {
                this.events.emit({
                    type: "shown"
                });
            }
        };
        Object.defineProperty(NgPasswordValidatorComponent.prototype, "show", {
            get: function () {
                return this.Show;
            },
            set: function (value) {
                if (value) {
                    this.setPosition();
                }
                this.Show = this.hostClassShow = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgPasswordValidatorComponent.prototype, "placement", {
            get: function () {
                return this.data.options.placement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgPasswordValidatorComponent.prototype, "element", {
            get: function () {
                return this.data.element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgPasswordValidatorComponent.prototype, "elementPosition", {
            get: function () {
                return this.data.elementPosition;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgPasswordValidatorComponent.prototype, "options", {
            get: function () {
                return this.data.options;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgPasswordValidatorComponent.prototype, "popupOffset", {
            get: function () {
                switch (this.data.options.offset) {
                    case "":
                        return defaultOptions.offset;
                    case "0":
                        return +this.data.options.offset;
                    default:
                        return +this.data.options.offset;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgPasswordValidatorComponent.prototype, "rules", {
            get: function () {
                return __assign(__assign({}, this.data.defaultOptions.rules), this.data.options.rules);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgPasswordValidatorComponent.prototype, "defaultOptions", {
            get: function () {
                return this.data.defaultOptions;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Component initialization
         *
         * @memberof NgPasswordValidatorComponent
         */
        NgPasswordValidatorComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.setCustomClass();
            this.setStyles();
            this.setTheme();
            this.setCustomText();
            this.dataService.updatedValue.subscribe(function (data) {
                _this.passwordStatus = __assign(__assign({}, _this.passwordStatus), data);
                for (var propName in _this.passwordOptions.rules) {
                    if (!_this.passwordOptions.rules[propName]) {
                        delete _this.passwordStatus[propName];
                    }
                }
                _this.isSecure = Object.values(_this.passwordStatus).every(function (value) { return value; });
            });
        };
        NgPasswordValidatorComponent.prototype.ngOnChanges = function (changes) {
            if (changes && changes.data && changes.data.currentValue) {
                this.data = changes.data.currentValue;
            }
        };
        /**
         * Set popup window position
         *
         * @returns {void}
         * @memberof NgPasswordValidatorComponent
         */
        NgPasswordValidatorComponent.prototype.setPosition = function () {
            var e_1, _a;
            if (this.setHostStyle(this.placement)) {
                this.setPlacementClass(this.placement);
                return;
            }
            else {
                // Is popup outside the visible area
                var placements = ["top", "right", "bottom", "left"];
                var isPlacementSet = void 0;
                try {
                    for (var placements_1 = __values(placements), placements_1_1 = placements_1.next(); !placements_1_1.done; placements_1_1 = placements_1.next()) {
                        var placement = placements_1_1.value;
                        if (this.setHostStyle(placement)) {
                            this.setPlacementClass(placement);
                            isPlacementSet = true;
                            return;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (placements_1_1 && !placements_1_1.done && (_a = placements_1.return)) _a.call(placements_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                // Set original placement
                if (!isPlacementSet) {
                    this.setHostStyle(this.placement);
                    this.setPlacementClass(this.placement);
                }
            }
        };
        /**
         * Set popup placement class
         *
         * @param {string} placement
         * @memberof NgPasswordValidatorComponent
         */
        NgPasswordValidatorComponent.prototype.setPlacementClass = function (placement) {
            this.renderer.addClass(this.elementRef.nativeElement, "popup-" + placement);
        };
        /**
         * Set host element style
         *
         * @param {string} placement
         * @returns {boolean}
         * @memberof NgPasswordValidatorComponent
         */
        NgPasswordValidatorComponent.prototype.setHostStyle = function (placement) {
            var isSvg = this.element instanceof SVGElement;
            var popup = this.elementRef.nativeElement;
            var isCustomPosition = !this.elementPosition.right;
            var elementHeight = isSvg ? this.element.getBoundingClientRect().height : this.element.offsetHeight;
            var elementWidth = isSvg ? this.element.getBoundingClientRect().width : this.element.offsetWidth;
            var popupHeight = popup.clientHeight;
            var popupWidth = popup.clientWidth;
            var scrollY = window.pageYOffset;
            if (isCustomPosition) {
                elementHeight = 0;
                elementWidth = 0;
            }
            var topStyle;
            var leftStyle;
            switch (placement) {
                case "top":
                    topStyle = (this.elementPosition.top + scrollY) - (popupHeight + this.popupOffset);
                    leftStyle = this.elementPosition.left;
                    break;
                case "bottom":
                    topStyle = (this.elementPosition.top + scrollY) + elementHeight + this.popupOffset;
                    leftStyle = this.elementPosition.left;
                    break;
                case "left":
                    leftStyle = this.elementPosition.left - popupWidth - this.popupOffset;
                    topStyle = (this.elementPosition.top + scrollY);
                    break;
                case "right":
                    leftStyle = this.elementPosition.left + elementWidth + this.popupOffset;
                    topStyle = (this.elementPosition.top + scrollY);
            }
            this.hostStyleTop = topStyle + "px";
            this.hostStyleLeft = leftStyle + "px";
            return true;
        };
        /**
         * Sets Z-index
         *
         * @memberof NgPasswordValidatorComponent
         */
        NgPasswordValidatorComponent.prototype.setZIndex = function () {
            if (this.options["z-index"] !== 0) {
                this.hostStyleZIndex = this.options["z-index"];
            }
        };
        /**
         * Ste custom class name
         *
         * @memberof NgPasswordValidatorComponent
         */
        NgPasswordValidatorComponent.prototype.setCustomClass = function () {
            var _this = this;
            if (this.options["customClass"]) {
                this.options["customClass"].split(" ").forEach(function (className) {
                    _this.renderer.addClass(_this.elementRef.nativeElement, className);
                });
            }
        };
        /**
         * Set theme
         *
         * @memberof NgPasswordValidatorComponent
         */
        NgPasswordValidatorComponent.prototype.setTheme = function () {
            if (this.options["theme"]) {
                this.renderer.addClass(this.elementRef.nativeElement, "popup-" + this.options["theme"]);
            }
        };
        NgPasswordValidatorComponent.prototype.setCustomText = function () {
            if (this.options["heading"]) {
                this.heading = this.options["heading"];
            }
            if (this.options["successMessage"]) {
                this.successMessage = this.options["successMessage"];
            }
        };
        /**
         * Sets the animation duration
         *
         * @memberof NgPasswordValidatorComponent
         */
        NgPasswordValidatorComponent.prototype.setAnimationDuration = function () {
            this.hostStyleTransition = "opacity " + this.options["animation-duration"] + "ms";
        };
        /**
         * Set popup window style
         *
         * @memberof NgPasswordValidatorComponent
         */
        NgPasswordValidatorComponent.prototype.setStyles = function () {
            this.setZIndex();
            this.setAnimationDuration();
            this.hostClassShadow = this.options["shadow"];
            this.hostStyleMaxWidth = this.options["max-width"] + "px";
            this.hostStyleWidth = this.options["width"] ? this.options["width"] + "px" : "";
        };
        NgPasswordValidatorComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: DataService }
        ]; };
        __decorate([
            core.Input()
        ], NgPasswordValidatorComponent.prototype, "data", void 0);
        __decorate([
            core.HostBinding("style.top")
        ], NgPasswordValidatorComponent.prototype, "hostStyleTop", void 0);
        __decorate([
            core.HostBinding("style.left")
        ], NgPasswordValidatorComponent.prototype, "hostStyleLeft", void 0);
        __decorate([
            core.HostBinding("style.z-index")
        ], NgPasswordValidatorComponent.prototype, "hostStyleZIndex", void 0);
        __decorate([
            core.HostBinding("style.transition")
        ], NgPasswordValidatorComponent.prototype, "hostStyleTransition", void 0);
        __decorate([
            core.HostBinding("style.width")
        ], NgPasswordValidatorComponent.prototype, "hostStyleWidth", void 0);
        __decorate([
            core.HostBinding("style.max-width")
        ], NgPasswordValidatorComponent.prototype, "hostStyleMaxWidth", void 0);
        __decorate([
            core.HostBinding("style.pointer-events")
        ], NgPasswordValidatorComponent.prototype, "hostStylePointerEvents", void 0);
        __decorate([
            core.HostBinding("class.popup-show")
        ], NgPasswordValidatorComponent.prototype, "hostClassShow", void 0);
        __decorate([
            core.HostBinding("class.popup-shadow")
        ], NgPasswordValidatorComponent.prototype, "hostClassShadow", void 0);
        __decorate([
            core.HostListener("transitionend", [""])
        ], NgPasswordValidatorComponent.prototype, "transitionEnd", null);
        __decorate([
            core.Input()
        ], NgPasswordValidatorComponent.prototype, "show", null);
        NgPasswordValidatorComponent = __decorate([
            core.Component({
                selector: "NgPasswordValidator",
                template: "<div class=\"popup-window\">\n    <div class=\"heading\">{{heading}}</div>\n    <div *ngIf=\"rules['password']\">\n        <div class=\"rule\" [hidden]=\"rules['password'].type !== 'number'\"\n            [ngClass]=\"{'rule-pass':passwordStatus['password']}\">\n            Password length should be {{rules['password'].length}} characters.\n        </div>\n        <div class=\"rule\" [hidden]=\"rules['password'].type !== 'range'\"\n            [ngClass]=\"{'rule-pass':passwordStatus['password']}\">\n            Password length should be {{rules['password'].min}} - {{rules['password'].max}}\n            characters.\n        </div>\n    </div>\n    <div class=\"rule\" [hidden]=\"!rules['include-symbol']\"\n        [ngClass]=\"{'rule-pass':passwordStatus['include-symbol']}\">\n        Include Symbols:( e.g. @#$% )\n    </div>\n    <div class=\"rule\" [hidden]=\"!rules['include-number']\"\n        [ngClass]=\"{'rule-pass':passwordStatus['include-number']}\">\n        Include Numbers:( e.g.123456 )\n    </div>\n    <div class=\"rule\" [hidden]=\"!rules['include-lowercase-characters']\"\n        [ngClass]=\"{'rule-pass':passwordStatus['include-lowercase-characters']}\">\n        Include Lowercase Characters:(e.g. abcdefgh )\n    </div>\n    <div class=\"rule\" [hidden]=\"!rules['include-uppercase-characters']\"\n        [ngClass]=\"{'rule-pass':passwordStatus['include-uppercase-characters']}\">\n        Include Uppercase Characters:(e.g. ABCDEFGH )\n    </div>\n    <div class=\"success-message\" [hidden]=\"!isSecure\">\n        {{successMessage}}\n    </div>\n</div>\n",
                host: { class: "popup" },
                styles: ["@charset \"UTF-8\";:host{max-width:390px;background-color:#fff;color:#000;text-align:left;border-radius:6px;position:absolute;pointer-events:none;padding:10px;z-index:1000;display:block;opacity:0;transition:opacity .3s ease-in-out;top:0;left:0}:host.popup-show{opacity:1}:host.popup-shadow{box-shadow:0 1px 5px 0 rgba(0,0,0,.4)}:host.popup .popup-window .heading{font-size:16px;color:#000;margin-bottom:.5rem;font-weight:700}:host.popup .popup-window .rule{font-size:14px;color:#6a6a6a;line-height:18px;margin:3px 0}:host.popup .popup-window .rule::before{content:\"\\a\";width:5px;height:5px;border-radius:50%;background:#6a6a6a;display:inline-block;vertical-align:sub;margin:0 10px 6px 0}:host.popup .popup-window .rule.rule-pass{text-decoration:line-through;color:#d3d3d3}:host.popup .popup-window .rule.rule-pass::before{background:#d3d3d3}:host.popup .popup-window .success-message{color:#28a745;text-align:center;font-size:16px;margin-top:5px}:host.popup.popup-pro .popup-window .rule.rule-pass{color:#28a745;text-decoration:none}:host.popup.popup-pro .popup-window .rule.rule-pass::before{content:\"\u2713\"!important;width:0;height:0;padding-right:5px;vertical-align:inherit;background:#28a745}:host.popup.popup-pro .popup-window .success-message{color:#9c0404}"]
            })
        ], NgPasswordValidatorComponent);
        return NgPasswordValidatorComponent;
    }());

    var NgPasswordValidatorDirective = /** @class */ (function () {
        function NgPasswordValidatorDirective(initOptions, elementRef, componentFactoryResolver, appRef, dataService, injector) {
            this.initOptions = initOptions;
            this.elementRef = elementRef;
            this.componentFactoryResolver = componentFactoryResolver;
            this.appRef = appRef;
            this.dataService = dataService;
            this.injector = injector;
            this.regExpForLength = /^(.){8}$/;
            this.regExpForOneUpper = /^(?=.*[A-Z])(.*)$/;
            this.regExpForOneLower = /^(?=.*[a-z])(.*)$/;
            this.regExpForOneDigit = /^(?=.*[0-9])(.*)$/;
            this.regExpForSpecialCharacters = /^(?=.*[!@#$%^&*])([a-zA-Z0-9!@#$%^&*]*)$/;
            this.isValid = false;
            this.inputValue = "";
            this.events = new core.EventEmitter();
            this.valid = new core.EventEmitter();
        }
        Object.defineProperty(NgPasswordValidatorDirective.prototype, "optionsInput", {
            set: function (value) {
                if (value && defaultOptions) {
                    this.passwordOptions = this.deepMerge(defaultOptions, value);
                    this.createPasswordRegex();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgPasswordValidatorDirective.prototype, "options", {
            get: function () {
                return this.passwordOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgPasswordValidatorDirective.prototype, "isPopupDestroyed", {
            get: function () {
                return this.componentRef && this.componentRef.hostView.destroyed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgPasswordValidatorDirective.prototype, "popupPosition", {
            /**
             * Get popup position
             *
             * @readonly
             * @type {(IElementPosition | IPosition)}
             * @memberof NgPasswordValidatorDirective
             */
            get: function () {
                if (this.options["position"]) {
                    return this.options["position"];
                }
                else {
                    return this.elementPosition;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Focus in input field
         *
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.onMouseEnter = function (value) {
            this.updatePasswordOptions();
            this.show();
            this.checkPassword(value);
        };
        /**
         * Update password options
         *
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.updatePasswordOptions = function () {
            if (this.popup && defaultOptions) {
                this.passwordOptions = this.deepMerge(defaultOptions, this.popup);
                this.createPasswordRegex();
            }
        };
        /**
         * Focus out of input field
         *
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.onMouseLeave = function () {
            this.destroyPopup();
            this.valid.emit(this.isValid);
        };
        /**
         * Input field value
         *
         * @param {string} value
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.onInput = function (value) {
            this.checkPassword(value);
        };
        /**
         * On input change
         *
         * @param {{ popup: SimpleChange }} changes
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.ngOnChanges = function (changes) {
            var changedOptions = this.getProperties(changes);
            this.applyOptionsDefault(changedOptions, defaultOptions);
        };
        /**
         * Destroy the pop up and unsubscribe to release the memory
         *
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.ngOnDestroy = function () {
            this.destroyPopup();
            if (this.componentSubscribe) {
                this.componentSubscribe.unsubscribe();
            }
        };
        /**
         * Deep merge objects
         *
         * @param {NgPasswordValidatorOptions} target
         * @param {NgPasswordValidatorOptions} source
         * @returns {NgPasswordValidatorOptions}
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.deepMerge = function (target, source) {
            var e_1, _a;
            try {
                // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties
                for (var _b = __values(Object.keys(source)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (source[key] instanceof Object) {
                        Object.assign(source[key], this.deepMerge(target[key], source[key]));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // Join `target` and modified `source`
            Object.assign(target || {}, source);
            return target;
        };
        /**
         * Create password regex
         *
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.createPasswordRegex = function () {
            if (this.passwordOptions.rules.password) {
                switch (this.passwordOptions.rules["password"].type) {
                    case "number":
                        this.regExpForLength = new RegExp("^(.){" + this.passwordOptions.rules["password"].length + "}$");
                        break;
                    case "range":
                        this.regExpForLength =
                            new RegExp("^(.){" + this.passwordOptions.rules["password"].min + "," + this.passwordOptions.rules["password"].max + "}$");
                }
            }
        };
        /**
         * Check password if valid or not
         *
         * @param {string} inputValue
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.checkPassword = function (inputValue) {
            var data = {
                password: inputValue && inputValue.length && inputValue.match(this.regExpForLength) ? true : false,
                "include-symbol": inputValue && inputValue.length && inputValue.match(this.regExpForSpecialCharacters) ? true : false,
                "include-number": inputValue && inputValue.length && inputValue.match(this.regExpForOneDigit) ? true : false,
                "include-lowercase-characters": inputValue && inputValue.length && inputValue.match(this.regExpForOneLower) ? true : false,
                "include-uppercase-characters": inputValue && inputValue.length && inputValue.match(this.regExpForOneUpper) ? true : false,
            };
            for (var propName in this.passwordOptions.rules) {
                if (!this.passwordOptions.rules[propName]) {
                    delete data[propName];
                }
            }
            this.isValid = Object.values(data).every(function (value) { return value; });
            this.dataService.updateValue(data);
        };
        /**
         * Get properties
         *
         * @param {{ popup: SimpleChange }} changes
         * @returns {{ popup: any }}
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.getProperties = function (changes) {
            var directiveProperties = {};
            var customProperties = {};
            var allProperties = {};
            // tslint:disable-next-line: forin
            for (var prop in changes) {
                if (prop !== "options") {
                    directiveProperties[prop] = changes[prop].currentValue;
                }
                if (prop === "options") {
                    customProperties = changes[prop].currentValue;
                }
            }
            allProperties = Object.assign({}, customProperties, directiveProperties);
            return allProperties;
        };
        /**
         * Get element position
         *
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.getElementPosition = function () {
            this.elementPosition = this.elementRef.nativeElement.getBoundingClientRect();
        };
        /**
         * Create Popup
         *
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.createPopup = function () {
            this.getElementPosition();
            this.appendComponentToBody(NgPasswordValidatorComponent);
            this.showPopupElem();
        };
        /**
         * Destroy Popup
         *
         * @returns {void}
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.destroyPopup = function () {
            if (!this.isPopupDestroyed) {
                this.hidePopup();
                if (!this.componentRef || this.isPopupDestroyed) {
                    return;
                }
                this.appRef.detachView(this.componentRef.hostView);
                this.componentRef.destroy();
                this.events.emit({
                    type: "hidden",
                    position: this.popupPosition
                });
            }
        };
        /**
         * Show popup window
         *
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.showPopupElem = function () {
            this.componentRef.instance.show = true;
            this.events.emit({
                type: "show",
                position: this.popupPosition
            });
        };
        /**
         * Hide popup window
         *
         * @returns {void}
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.hidePopup = function () {
            if (!this.componentRef || this.isPopupDestroyed) {
                return;
            }
            this.componentRef.instance.show = false;
            this.events.emit({
                type: "hide",
                position: this.popupPosition
            });
        };
        /**
         * Append created popup window to body
         *
         * @param {*} component
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.appendComponentToBody = function (component) {
            var _this = this;
            this.componentRef = this.componentFactoryResolver
                .resolveComponentFactory(component)
                .create(this.injector);
            this.componentRef.instance.data = {
                element: this.elementRef.nativeElement,
                elementPosition: this.popupPosition,
                options: this.options,
                defaultOptions: defaultOptions
            };
            this.appRef.attachView(this.componentRef.hostView);
            var domElem = this.componentRef.hostView.rootNodes[0];
            document.body.appendChild(domElem);
            this.componentSubscribe = this.componentRef.instance.events.subscribe(function (event) {
                _this.handleEvents(event);
            });
        };
        /**
         * Reset/switching back to default options
         *
         * @param {NgPasswordValidatorOptions} defaultOption
         * @param {{ popup: SimpleChange }} options
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.applyOptionsDefault = function (options, defaultOption) {
            this.initOptions = Object.assign({}, this.initOptions || {}, options, defaultOption);
        };
        /**
         * Handle events
         *
         * @param {*} event
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.handleEvents = function (event) {
            if (event.type === "shown") {
                this.events.emit({
                    type: "shown",
                    position: this.popupPosition
                });
            }
        };
        /**
         * It creates popup window to show password requirement
         *
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.show = function () {
            if (!this.componentRef || this.isPopupDestroyed) {
                this.createPopup();
            }
            else if (!this.isPopupDestroyed) {
                this.showPopupElem();
            }
        };
        /**
         * Hide/Destroys popup windows
         *
         * @memberof NgPasswordValidatorDirective
         */
        NgPasswordValidatorDirective.prototype.hide = function () {
            this.destroyPopup();
        };
        NgPasswordValidatorDirective.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [NgPasswordValidatorService,] }] },
            { type: core.ElementRef },
            { type: core.ComponentFactoryResolver },
            { type: core.ApplicationRef },
            { type: DataService },
            { type: core.Injector }
        ]; };
        __decorate([
            core.Input("options")
        ], NgPasswordValidatorDirective.prototype, "optionsInput", null);
        __decorate([
            core.Input("NgPasswordValidator")
        ], NgPasswordValidatorDirective.prototype, "popup", void 0);
        __decorate([
            core.Input("placement")
        ], NgPasswordValidatorDirective.prototype, "placement", void 0);
        __decorate([
            core.Input("z-index")
        ], NgPasswordValidatorDirective.prototype, "zIndex", void 0);
        __decorate([
            core.Input("animation-duration")
        ], NgPasswordValidatorDirective.prototype, "animationDuration", void 0);
        __decorate([
            core.Input("custom-class")
        ], NgPasswordValidatorDirective.prototype, "customClass", void 0);
        __decorate([
            core.Input("shadow")
        ], NgPasswordValidatorDirective.prototype, "shadow", void 0);
        __decorate([
            core.Input("theme")
        ], NgPasswordValidatorDirective.prototype, "theme", void 0);
        __decorate([
            core.Input("offset")
        ], NgPasswordValidatorDirective.prototype, "offset", void 0);
        __decorate([
            core.Input("width")
        ], NgPasswordValidatorDirective.prototype, "width", void 0);
        __decorate([
            core.Input("max-width")
        ], NgPasswordValidatorDirective.prototype, "maxWidth", void 0);
        __decorate([
            core.Input("position")
        ], NgPasswordValidatorDirective.prototype, "position", void 0);
        __decorate([
            core.Input("heading")
        ], NgPasswordValidatorDirective.prototype, "heading", void 0);
        __decorate([
            core.Input("successMessage")
        ], NgPasswordValidatorDirective.prototype, "successMessage", void 0);
        __decorate([
            core.Output()
        ], NgPasswordValidatorDirective.prototype, "events", void 0);
        __decorate([
            core.Output()
        ], NgPasswordValidatorDirective.prototype, "valid", void 0);
        __decorate([
            core.HostListener("focusin", ["$event.target.value"])
        ], NgPasswordValidatorDirective.prototype, "onMouseEnter", null);
        __decorate([
            core.HostListener("focusout")
        ], NgPasswordValidatorDirective.prototype, "onMouseLeave", null);
        __decorate([
            core.HostListener("input", ["$event.target.value"])
        ], NgPasswordValidatorDirective.prototype, "onInput", null);
        NgPasswordValidatorDirective = __decorate([
            core.Directive({
                selector: "[NgPasswordValidator]",
                exportAs: "NgPasswordValidator",
            }),
            __param(0, core.Optional()), __param(0, core.Inject(NgPasswordValidatorService))
        ], NgPasswordValidatorDirective);
        return NgPasswordValidatorDirective;
    }());

    var NgPasswordValidatorModule = /** @class */ (function () {
        function NgPasswordValidatorModule() {
        }
        NgPasswordValidatorModule_1 = NgPasswordValidatorModule;
        /**
         * Password validator module
         *
         * @static
         * @param {NgPasswordValidatorOptions} initOptions
         * @returns {ModuleWithProviders<NgPasswordValidatorModule>}
         * @memberof NgPasswordValidatorModule
         */
        NgPasswordValidatorModule.forRoot = function (initOptions) {
            return {
                ngModule: NgPasswordValidatorModule_1,
                providers: [
                    {
                        provide: NgPasswordValidatorService,
                        useValue: initOptions
                    }
                ]
            };
        };
        var NgPasswordValidatorModule_1;
        NgPasswordValidatorModule = NgPasswordValidatorModule_1 = __decorate([
            core.NgModule({
                declarations: [
                    NgPasswordValidatorDirective,
                    NgPasswordValidatorComponent,
                ],
                imports: [
                    common.CommonModule
                ],
                providers: [DataService],
                exports: [
                    NgPasswordValidatorDirective
                ],
                entryComponents: [
                    NgPasswordValidatorComponent
                ]
            })
        ], NgPasswordValidatorModule);
        return NgPasswordValidatorModule;
    }());

    exports.NgPasswordValidatorComponent = NgPasswordValidatorComponent;
    exports.NgPasswordValidatorDirective = NgPasswordValidatorDirective;
    exports.NgPasswordValidatorModule = NgPasswordValidatorModule;
    exports.NgPasswordValidatorService = NgPasswordValidatorService;
    exports.ɵa = DataService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ng-password-validator.umd.js.map
