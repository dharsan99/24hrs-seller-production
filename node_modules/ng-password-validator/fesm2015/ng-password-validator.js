import { InjectionToken, Injectable, EventEmitter, ElementRef, Renderer2, Input, HostBinding, HostListener, Component, Optional, Inject, ComponentFactoryResolver, ApplicationRef, Injector, Output, Directive, NgModule } from '@angular/core';
import { __decorate, __param } from 'tslib';
import { BehaviorSubject } from 'rxjs';
import { CommonModule } from '@angular/common';

/**
 * This is not a real service, but it looks like it from the outside.
 * It's just an InjectionToken used to import the config (initOptions) object, provided from the outside
 */
const NgPasswordValidatorService = new InjectionToken("NgPasswordValidatorOptions");

const defaultOptions = {
    placement: "bottom",
    "z-index": 0,
    "custom-class": "custom-class",
    shadow: true,
    theme: "pro",
    offset: 8,
    heading: "Password Policy",
    successMessage: "Awesome! Password requirement fulfilled.",
    rules: {
        password: {
            type: "range",
            length: 8,
            min: 6,
            max: 10,
        },
        "include-symbol": true,
        "include-number": true,
        "include-lowercase-characters": true,
        "include-uppercase-characters": true,
    }
};
const initializeStage = {
    password: false,
    "include-symbol": false,
    "include-number": false,
    "include-lowercase-characters": false,
    "include-uppercase-characters": false,
};

let DataService = class DataService {
    constructor() {
        this.value = new BehaviorSubject(initializeStage);
        this.updatedValue = this.value.asObservable();
    }
    /**
     * Update value
     *
     * @param {IStatus} data
     * @memberof DataService
     */
    updateValue(data) {
        this.value.next(data);
    }
};
DataService = __decorate([
    Injectable()
], DataService);

let NgPasswordValidatorComponent = class NgPasswordValidatorComponent {
    constructor(elementRef, renderer, dataService) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.dataService = dataService;
        this.passwordStatus = {
            password: false,
            "include-symbol": false,
            "include-number": false,
            "include-lowercase-characters": false,
            "include-uppercase-characters": false,
        };
        this.isSecure = false;
        this.Show = false;
        this.events = new EventEmitter();
        this.passwordOptions = Object.assign({}, defaultOptions);
    }
    /**
     * Host listener transition end
     *
     * @memberof NgPasswordValidatorComponent
     */
    transitionEnd() {
        if (this.show) {
            this.events.emit({
                type: "shown"
            });
        }
    }
    set show(value) {
        if (value) {
            this.setPosition();
        }
        this.Show = this.hostClassShow = value;
    }
    get show() {
        return this.Show;
    }
    get placement() {
        return this.data.options.placement;
    }
    get element() {
        return this.data.element;
    }
    get elementPosition() {
        return this.data.elementPosition;
    }
    get options() {
        return this.data.options;
    }
    get popupOffset() {
        switch (this.data.options.offset) {
            case "":
                return defaultOptions.offset;
            case "0":
                return +this.data.options.offset;
            default:
                return +this.data.options.offset;
        }
    }
    get rules() {
        return Object.assign(Object.assign({}, this.data.defaultOptions.rules), this.data.options.rules);
    }
    get defaultOptions() {
        return this.data.defaultOptions;
    }
    /**
     * Component initialization
     *
     * @memberof NgPasswordValidatorComponent
     */
    ngOnInit() {
        this.setCustomClass();
        this.setStyles();
        this.setTheme();
        this.setCustomText();
        this.dataService.updatedValue.subscribe((data) => {
            this.passwordStatus = Object.assign(Object.assign({}, this.passwordStatus), data);
            for (const propName in this.passwordOptions.rules) {
                if (!this.passwordOptions.rules[propName]) {
                    delete this.passwordStatus[propName];
                }
            }
            this.isSecure = Object.values(this.passwordStatus).every((value) => value);
        });
    }
    ngOnChanges(changes) {
        if (changes && changes.data && changes.data.currentValue) {
            this.data = changes.data.currentValue;
        }
    }
    /**
     * Set popup window position
     *
     * @returns {void}
     * @memberof NgPasswordValidatorComponent
     */
    setPosition() {
        if (this.setHostStyle(this.placement)) {
            this.setPlacementClass(this.placement);
            return;
        }
        else {
            // Is popup outside the visible area
            const placements = ["top", "right", "bottom", "left"];
            let isPlacementSet;
            for (const placement of placements) {
                if (this.setHostStyle(placement)) {
                    this.setPlacementClass(placement);
                    isPlacementSet = true;
                    return;
                }
            }
            // Set original placement
            if (!isPlacementSet) {
                this.setHostStyle(this.placement);
                this.setPlacementClass(this.placement);
            }
        }
    }
    /**
     * Set popup placement class
     *
     * @param {string} placement
     * @memberof NgPasswordValidatorComponent
     */
    setPlacementClass(placement) {
        this.renderer.addClass(this.elementRef.nativeElement, "popup-" + placement);
    }
    /**
     * Set host element style
     *
     * @param {string} placement
     * @returns {boolean}
     * @memberof NgPasswordValidatorComponent
     */
    setHostStyle(placement) {
        const isSvg = this.element instanceof SVGElement;
        const popup = this.elementRef.nativeElement;
        const isCustomPosition = !this.elementPosition.right;
        let elementHeight = isSvg ? this.element.getBoundingClientRect().height : this.element.offsetHeight;
        let elementWidth = isSvg ? this.element.getBoundingClientRect().width : this.element.offsetWidth;
        const popupHeight = popup.clientHeight;
        const popupWidth = popup.clientWidth;
        const scrollY = window.pageYOffset;
        if (isCustomPosition) {
            elementHeight = 0;
            elementWidth = 0;
        }
        let topStyle;
        let leftStyle;
        switch (placement) {
            case "top":
                topStyle = (this.elementPosition.top + scrollY) - (popupHeight + this.popupOffset);
                leftStyle = this.elementPosition.left;
                break;
            case "bottom":
                topStyle = (this.elementPosition.top + scrollY) + elementHeight + this.popupOffset;
                leftStyle = this.elementPosition.left;
                break;
            case "left":
                leftStyle = this.elementPosition.left - popupWidth - this.popupOffset;
                topStyle = (this.elementPosition.top + scrollY);
                break;
            case "right":
                leftStyle = this.elementPosition.left + elementWidth + this.popupOffset;
                topStyle = (this.elementPosition.top + scrollY);
        }
        this.hostStyleTop = topStyle + "px";
        this.hostStyleLeft = leftStyle + "px";
        return true;
    }
    /**
     * Sets Z-index
     *
     * @memberof NgPasswordValidatorComponent
     */
    setZIndex() {
        if (this.options["z-index"] !== 0) {
            this.hostStyleZIndex = this.options["z-index"];
        }
    }
    /**
     * Ste custom class name
     *
     * @memberof NgPasswordValidatorComponent
     */
    setCustomClass() {
        if (this.options["customClass"]) {
            this.options["customClass"].split(" ").forEach((className) => {
                this.renderer.addClass(this.elementRef.nativeElement, className);
            });
        }
    }
    /**
     * Set theme
     *
     * @memberof NgPasswordValidatorComponent
     */
    setTheme() {
        if (this.options["theme"]) {
            this.renderer.addClass(this.elementRef.nativeElement, "popup-" + this.options["theme"]);
        }
    }
    setCustomText() {
        if (this.options["heading"]) {
            this.heading = this.options["heading"];
        }
        if (this.options["successMessage"]) {
            this.successMessage = this.options["successMessage"];
        }
    }
    /**
     * Sets the animation duration
     *
     * @memberof NgPasswordValidatorComponent
     */
    setAnimationDuration() {
        this.hostStyleTransition = "opacity " + this.options["animation-duration"] + "ms";
    }
    /**
     * Set popup window style
     *
     * @memberof NgPasswordValidatorComponent
     */
    setStyles() {
        this.setZIndex();
        this.setAnimationDuration();
        this.hostClassShadow = this.options["shadow"];
        this.hostStyleMaxWidth = this.options["max-width"] + "px";
        this.hostStyleWidth = this.options["width"] ? this.options["width"] + "px" : "";
    }
};
NgPasswordValidatorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: DataService }
];
__decorate([
    Input()
], NgPasswordValidatorComponent.prototype, "data", void 0);
__decorate([
    HostBinding("style.top")
], NgPasswordValidatorComponent.prototype, "hostStyleTop", void 0);
__decorate([
    HostBinding("style.left")
], NgPasswordValidatorComponent.prototype, "hostStyleLeft", void 0);
__decorate([
    HostBinding("style.z-index")
], NgPasswordValidatorComponent.prototype, "hostStyleZIndex", void 0);
__decorate([
    HostBinding("style.transition")
], NgPasswordValidatorComponent.prototype, "hostStyleTransition", void 0);
__decorate([
    HostBinding("style.width")
], NgPasswordValidatorComponent.prototype, "hostStyleWidth", void 0);
__decorate([
    HostBinding("style.max-width")
], NgPasswordValidatorComponent.prototype, "hostStyleMaxWidth", void 0);
__decorate([
    HostBinding("style.pointer-events")
], NgPasswordValidatorComponent.prototype, "hostStylePointerEvents", void 0);
__decorate([
    HostBinding("class.popup-show")
], NgPasswordValidatorComponent.prototype, "hostClassShow", void 0);
__decorate([
    HostBinding("class.popup-shadow")
], NgPasswordValidatorComponent.prototype, "hostClassShadow", void 0);
__decorate([
    HostListener("transitionend", [""])
], NgPasswordValidatorComponent.prototype, "transitionEnd", null);
__decorate([
    Input()
], NgPasswordValidatorComponent.prototype, "show", null);
NgPasswordValidatorComponent = __decorate([
    Component({
        selector: "NgPasswordValidator",
        template: "<div class=\"popup-window\">\n    <div class=\"heading\">{{heading}}</div>\n    <div *ngIf=\"rules['password']\">\n        <div class=\"rule\" [hidden]=\"rules['password'].type !== 'number'\"\n            [ngClass]=\"{'rule-pass':passwordStatus['password']}\">\n            Password length should be {{rules['password'].length}} characters.\n        </div>\n        <div class=\"rule\" [hidden]=\"rules['password'].type !== 'range'\"\n            [ngClass]=\"{'rule-pass':passwordStatus['password']}\">\n            Password length should be {{rules['password'].min}} - {{rules['password'].max}}\n            characters.\n        </div>\n    </div>\n    <div class=\"rule\" [hidden]=\"!rules['include-symbol']\"\n        [ngClass]=\"{'rule-pass':passwordStatus['include-symbol']}\">\n        Include Symbols:( e.g. @#$% )\n    </div>\n    <div class=\"rule\" [hidden]=\"!rules['include-number']\"\n        [ngClass]=\"{'rule-pass':passwordStatus['include-number']}\">\n        Include Numbers:( e.g.123456 )\n    </div>\n    <div class=\"rule\" [hidden]=\"!rules['include-lowercase-characters']\"\n        [ngClass]=\"{'rule-pass':passwordStatus['include-lowercase-characters']}\">\n        Include Lowercase Characters:(e.g. abcdefgh )\n    </div>\n    <div class=\"rule\" [hidden]=\"!rules['include-uppercase-characters']\"\n        [ngClass]=\"{'rule-pass':passwordStatus['include-uppercase-characters']}\">\n        Include Uppercase Characters:(e.g. ABCDEFGH )\n    </div>\n    <div class=\"success-message\" [hidden]=\"!isSecure\">\n        {{successMessage}}\n    </div>\n</div>\n",
        host: { class: "popup" },
        styles: ["@charset \"UTF-8\";:host{max-width:390px;background-color:#fff;color:#000;text-align:left;border-radius:6px;position:absolute;pointer-events:none;padding:10px;z-index:1000;display:block;opacity:0;transition:opacity .3s ease-in-out;top:0;left:0}:host.popup-show{opacity:1}:host.popup-shadow{box-shadow:0 1px 5px 0 rgba(0,0,0,.4)}:host.popup .popup-window .heading{font-size:16px;color:#000;margin-bottom:.5rem;font-weight:700}:host.popup .popup-window .rule{font-size:14px;color:#6a6a6a;line-height:18px;margin:3px 0}:host.popup .popup-window .rule::before{content:\"\\a\";width:5px;height:5px;border-radius:50%;background:#6a6a6a;display:inline-block;vertical-align:sub;margin:0 10px 6px 0}:host.popup .popup-window .rule.rule-pass{text-decoration:line-through;color:#d3d3d3}:host.popup .popup-window .rule.rule-pass::before{background:#d3d3d3}:host.popup .popup-window .success-message{color:#28a745;text-align:center;font-size:16px;margin-top:5px}:host.popup.popup-pro .popup-window .rule.rule-pass{color:#28a745;text-decoration:none}:host.popup.popup-pro .popup-window .rule.rule-pass::before{content:\"\u2713\"!important;width:0;height:0;padding-right:5px;vertical-align:inherit;background:#28a745}:host.popup.popup-pro .popup-window .success-message{color:#9c0404}"]
    })
], NgPasswordValidatorComponent);

let NgPasswordValidatorDirective = class NgPasswordValidatorDirective {
    constructor(initOptions, elementRef, componentFactoryResolver, appRef, dataService, injector) {
        this.initOptions = initOptions;
        this.elementRef = elementRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.appRef = appRef;
        this.dataService = dataService;
        this.injector = injector;
        this.regExpForLength = /^(.){8}$/;
        this.regExpForOneUpper = /^(?=.*[A-Z])(.*)$/;
        this.regExpForOneLower = /^(?=.*[a-z])(.*)$/;
        this.regExpForOneDigit = /^(?=.*[0-9])(.*)$/;
        this.regExpForSpecialCharacters = /^(?=.*[!@#$%^&*])([a-zA-Z0-9!@#$%^&*]*)$/;
        this.isValid = false;
        this.inputValue = "";
        this.events = new EventEmitter();
        this.valid = new EventEmitter();
    }
    set optionsInput(value) {
        if (value && defaultOptions) {
            this.passwordOptions = this.deepMerge(defaultOptions, value);
            this.createPasswordRegex();
        }
    }
    get options() {
        return this.passwordOptions;
    }
    get isPopupDestroyed() {
        return this.componentRef && this.componentRef.hostView.destroyed;
    }
    /**
     * Get popup position
     *
     * @readonly
     * @type {(IElementPosition | IPosition)}
     * @memberof NgPasswordValidatorDirective
     */
    get popupPosition() {
        if (this.options["position"]) {
            return this.options["position"];
        }
        else {
            return this.elementPosition;
        }
    }
    /**
     * Focus in input field
     *
     * @memberof NgPasswordValidatorDirective
     */
    onMouseEnter(value) {
        this.updatePasswordOptions();
        this.show();
        this.checkPassword(value);
    }
    /**
     * Update password options
     *
     * @memberof NgPasswordValidatorDirective
     */
    updatePasswordOptions() {
        if (this.popup && defaultOptions) {
            this.passwordOptions = this.deepMerge(defaultOptions, this.popup);
            this.createPasswordRegex();
        }
    }
    /**
     * Focus out of input field
     *
     * @memberof NgPasswordValidatorDirective
     */
    onMouseLeave() {
        this.destroyPopup();
        this.valid.emit(this.isValid);
    }
    /**
     * Input field value
     *
     * @param {string} value
     * @memberof NgPasswordValidatorDirective
     */
    onInput(value) {
        this.checkPassword(value);
    }
    /**
     * On input change
     *
     * @param {{ popup: SimpleChange }} changes
     * @memberof NgPasswordValidatorDirective
     */
    ngOnChanges(changes) {
        const changedOptions = this.getProperties(changes);
        this.applyOptionsDefault(changedOptions, defaultOptions);
    }
    /**
     * Destroy the pop up and unsubscribe to release the memory
     *
     * @memberof NgPasswordValidatorDirective
     */
    ngOnDestroy() {
        this.destroyPopup();
        if (this.componentSubscribe) {
            this.componentSubscribe.unsubscribe();
        }
    }
    /**
     * Deep merge objects
     *
     * @param {NgPasswordValidatorOptions} target
     * @param {NgPasswordValidatorOptions} source
     * @returns {NgPasswordValidatorOptions}
     * @memberof NgPasswordValidatorDirective
     */
    deepMerge(target, source) {
        // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties
        for (const key of Object.keys(source)) {
            if (source[key] instanceof Object) {
                Object.assign(source[key], this.deepMerge(target[key], source[key]));
            }
        }
        // Join `target` and modified `source`
        Object.assign(target || {}, source);
        return target;
    }
    /**
     * Create password regex
     *
     * @memberof NgPasswordValidatorDirective
     */
    createPasswordRegex() {
        if (this.passwordOptions.rules.password) {
            switch (this.passwordOptions.rules["password"].type) {
                case "number":
                    this.regExpForLength = new RegExp(`^(.){${this.passwordOptions.rules["password"].length}}$`);
                    break;
                case "range":
                    this.regExpForLength =
                        new RegExp(`^(.){${this.passwordOptions.rules["password"].min},${this.passwordOptions.rules["password"].max}}$`);
            }
        }
    }
    /**
     * Check password if valid or not
     *
     * @param {string} inputValue
     * @memberof NgPasswordValidatorDirective
     */
    checkPassword(inputValue) {
        const data = {
            password: inputValue && inputValue.length && inputValue.match(this.regExpForLength) ? true : false,
            "include-symbol": inputValue && inputValue.length && inputValue.match(this.regExpForSpecialCharacters) ? true : false,
            "include-number": inputValue && inputValue.length && inputValue.match(this.regExpForOneDigit) ? true : false,
            "include-lowercase-characters": inputValue && inputValue.length && inputValue.match(this.regExpForOneLower) ? true : false,
            "include-uppercase-characters": inputValue && inputValue.length && inputValue.match(this.regExpForOneUpper) ? true : false,
        };
        for (const propName in this.passwordOptions.rules) {
            if (!this.passwordOptions.rules[propName]) {
                delete data[propName];
            }
        }
        this.isValid = Object.values(data).every((value) => value);
        this.dataService.updateValue(data);
    }
    /**
     * Get properties
     *
     * @param {{ popup: SimpleChange }} changes
     * @returns {{ popup: any }}
     * @memberof NgPasswordValidatorDirective
     */
    getProperties(changes) {
        const directiveProperties = {};
        let customProperties = {};
        let allProperties = {};
        // tslint:disable-next-line: forin
        for (const prop in changes) {
            if (prop !== "options") {
                directiveProperties[prop] = changes[prop].currentValue;
            }
            if (prop === "options") {
                customProperties = changes[prop].currentValue;
            }
        }
        allProperties = Object.assign({}, customProperties, directiveProperties);
        return allProperties;
    }
    /**
     * Get element position
     *
     * @memberof NgPasswordValidatorDirective
     */
    getElementPosition() {
        this.elementPosition = this.elementRef.nativeElement.getBoundingClientRect();
    }
    /**
     * Create Popup
     *
     * @memberof NgPasswordValidatorDirective
     */
    createPopup() {
        this.getElementPosition();
        this.appendComponentToBody(NgPasswordValidatorComponent);
        this.showPopupElem();
    }
    /**
     * Destroy Popup
     *
     * @returns {void}
     * @memberof NgPasswordValidatorDirective
     */
    destroyPopup() {
        if (!this.isPopupDestroyed) {
            this.hidePopup();
            if (!this.componentRef || this.isPopupDestroyed) {
                return;
            }
            this.appRef.detachView(this.componentRef.hostView);
            this.componentRef.destroy();
            this.events.emit({
                type: "hidden",
                position: this.popupPosition
            });
        }
    }
    /**
     * Show popup window
     *
     * @memberof NgPasswordValidatorDirective
     */
    showPopupElem() {
        this.componentRef.instance.show = true;
        this.events.emit({
            type: "show",
            position: this.popupPosition
        });
    }
    /**
     * Hide popup window
     *
     * @returns {void}
     * @memberof NgPasswordValidatorDirective
     */
    hidePopup() {
        if (!this.componentRef || this.isPopupDestroyed) {
            return;
        }
        this.componentRef.instance.show = false;
        this.events.emit({
            type: "hide",
            position: this.popupPosition
        });
    }
    /**
     * Append created popup window to body
     *
     * @param {*} component
     * @memberof NgPasswordValidatorDirective
     */
    appendComponentToBody(component) {
        this.componentRef = this.componentFactoryResolver
            .resolveComponentFactory(component)
            .create(this.injector);
        this.componentRef.instance.data = {
            element: this.elementRef.nativeElement,
            elementPosition: this.popupPosition,
            options: this.options,
            defaultOptions
        };
        this.appRef.attachView(this.componentRef.hostView);
        const domElem = this.componentRef.hostView.rootNodes[0];
        document.body.appendChild(domElem);
        this.componentSubscribe = this.componentRef.instance.events.subscribe((event) => {
            this.handleEvents(event);
        });
    }
    /**
     * Reset/switching back to default options
     *
     * @param {NgPasswordValidatorOptions} defaultOption
     * @param {{ popup: SimpleChange }} options
     * @memberof NgPasswordValidatorDirective
     */
    applyOptionsDefault(options, defaultOption) {
        this.initOptions = Object.assign({}, this.initOptions || {}, options, defaultOption);
    }
    /**
     * Handle events
     *
     * @param {*} event
     * @memberof NgPasswordValidatorDirective
     */
    handleEvents(event) {
        if (event.type === "shown") {
            this.events.emit({
                type: "shown",
                position: this.popupPosition
            });
        }
    }
    /**
     * It creates popup window to show password requirement
     *
     * @memberof NgPasswordValidatorDirective
     */
    show() {
        if (!this.componentRef || this.isPopupDestroyed) {
            this.createPopup();
        }
        else if (!this.isPopupDestroyed) {
            this.showPopupElem();
        }
    }
    /**
     * Hide/Destroys popup windows
     *
     * @memberof NgPasswordValidatorDirective
     */
    hide() {
        this.destroyPopup();
    }
};
NgPasswordValidatorDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NgPasswordValidatorService,] }] },
    { type: ElementRef },
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: DataService },
    { type: Injector }
];
__decorate([
    Input("options")
], NgPasswordValidatorDirective.prototype, "optionsInput", null);
__decorate([
    Input("NgPasswordValidator")
], NgPasswordValidatorDirective.prototype, "popup", void 0);
__decorate([
    Input("placement")
], NgPasswordValidatorDirective.prototype, "placement", void 0);
__decorate([
    Input("z-index")
], NgPasswordValidatorDirective.prototype, "zIndex", void 0);
__decorate([
    Input("animation-duration")
], NgPasswordValidatorDirective.prototype, "animationDuration", void 0);
__decorate([
    Input("custom-class")
], NgPasswordValidatorDirective.prototype, "customClass", void 0);
__decorate([
    Input("shadow")
], NgPasswordValidatorDirective.prototype, "shadow", void 0);
__decorate([
    Input("theme")
], NgPasswordValidatorDirective.prototype, "theme", void 0);
__decorate([
    Input("offset")
], NgPasswordValidatorDirective.prototype, "offset", void 0);
__decorate([
    Input("width")
], NgPasswordValidatorDirective.prototype, "width", void 0);
__decorate([
    Input("max-width")
], NgPasswordValidatorDirective.prototype, "maxWidth", void 0);
__decorate([
    Input("position")
], NgPasswordValidatorDirective.prototype, "position", void 0);
__decorate([
    Input("heading")
], NgPasswordValidatorDirective.prototype, "heading", void 0);
__decorate([
    Input("successMessage")
], NgPasswordValidatorDirective.prototype, "successMessage", void 0);
__decorate([
    Output()
], NgPasswordValidatorDirective.prototype, "events", void 0);
__decorate([
    Output()
], NgPasswordValidatorDirective.prototype, "valid", void 0);
__decorate([
    HostListener("focusin", ["$event.target.value"])
], NgPasswordValidatorDirective.prototype, "onMouseEnter", null);
__decorate([
    HostListener("focusout")
], NgPasswordValidatorDirective.prototype, "onMouseLeave", null);
__decorate([
    HostListener("input", ["$event.target.value"])
], NgPasswordValidatorDirective.prototype, "onInput", null);
NgPasswordValidatorDirective = __decorate([
    Directive({
        selector: "[NgPasswordValidator]",
        exportAs: "NgPasswordValidator",
    }),
    __param(0, Optional()), __param(0, Inject(NgPasswordValidatorService))
], NgPasswordValidatorDirective);

var NgPasswordValidatorModule_1;
let NgPasswordValidatorModule = NgPasswordValidatorModule_1 = class NgPasswordValidatorModule {
    /**
     * Password validator module
     *
     * @static
     * @param {NgPasswordValidatorOptions} initOptions
     * @returns {ModuleWithProviders<NgPasswordValidatorModule>}
     * @memberof NgPasswordValidatorModule
     */
    static forRoot(initOptions) {
        return {
            ngModule: NgPasswordValidatorModule_1,
            providers: [
                {
                    provide: NgPasswordValidatorService,
                    useValue: initOptions
                }
            ]
        };
    }
};
NgPasswordValidatorModule = NgPasswordValidatorModule_1 = __decorate([
    NgModule({
        declarations: [
            NgPasswordValidatorDirective,
            NgPasswordValidatorComponent,
        ],
        imports: [
            CommonModule
        ],
        providers: [DataService],
        exports: [
            NgPasswordValidatorDirective
        ],
        entryComponents: [
            NgPasswordValidatorComponent
        ]
    })
], NgPasswordValidatorModule);

/**
 * Generated bundle index. Do not edit.
 */

export { NgPasswordValidatorComponent, NgPasswordValidatorDirective, NgPasswordValidatorModule, NgPasswordValidatorService, DataService as ɵa };
//# sourceMappingURL=ng-password-validator.js.map
